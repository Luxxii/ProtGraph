import argparse
import os
from datetime import date
import tqdm

from protgraph.cli import check_if_file_exists



SWISS_EMBL_SKELETON = \
"""{ID_AC}
DT   {DAY}-{MONTH}-{YEAR}, integrated into UTA.
DT   {DAY}-{MONTH}-{YEAR}, sequence version 1.
DT   {DAY}-{MONTH}-{YEAR}, entry version 1.
DE   RecName: Full={PROTEIN_DESC};
GN   Name={GENE}; Synonyms={GENE}; ORFNames={GENE};
OS   Autogenerated.
OC   Autogenerated.
OX   NCBI_TaxID=0000;
RN   [1]
RP   AUTOGENERATED
RA   This file was autogenerated;
RT   "This is an autogenerated file.";
RL   (er) Autogenerated.
CC   -!- CAUTION: This file was autogenerated and is not
CC       taken from UniProt!
DR   UTA; {ENSP}; Universal Transcript Archive
PE   4: Predicted;
KW   Generated for ProtGraph{FT}
{SQ}
{SEQ_BODY}//
"""


def parse_args():
    """ Parse Arguments """
    parser = argparse.ArgumentParser(
        description="Small script to create a SP-EMBL-txt-Entries from FASTA-entries."
        "This can be very useful for FASTA-database and -entries, which are NOT in UniProt but should be utilized by ProtGraph."
        "Currently only a plain conversion from FASTA to SP-EMBL is provided. However this could be extended to include "
        "further feature information to peptides (like variants) using a csv entry. "
        "Note: The header should have 3 section '<pre>|<accession>|<description>', where the accession is unique for the whole FASTA-file."
    )

    # Number of entries in fasta (for tqdm)
    parser.add_argument(
        "--num_entries", "-n", type=int, default=None,
        help="Number of entries in the fasta files. if provided, it can give an estimate of the running time."
    )

    # Base Folder of generated Pickle Files
    parser.add_argument(
        "fasta_file", type=check_if_file_exists, nargs=1,
        help="Fasta file, where the header should be replaced"
    )

    # Feature-Table-Mapping
    # parser.add_argument(
    #     "--feature_tables", "-ft", type=str, default=None,
    #     help="Feature-Table-Mapping, to add additional information into the SP-EMBL, TODO"
    # )

    # Output SP-EMBL-file
    parser.add_argument(
        "--output", "-o", type=str, default="output.txt",
        help="Output fasta file. DEFAULT 'output.fasta' (NOTE: This file WILL be overwritten)"
    )

    return parser.parse_args()


def get_next_fasta_entry(fasta) -> tuple:
    """ Generator, returning parsed FASTA-entries """
    get_sequence = False # Flag to stop after the sequence was retrieved
    sequence = ""
    for line in fasta:
        # Iterate over each line of the FASTA-database
        if line.startswith(">"):
            # Case it is the header file
            if get_sequence:
                # We reached the next entry and can report the protein
                if sequence.isalpha() and sequence.isupper():
                    yield sequence, pre, accession, description
                    sequence = ""
                    get_sequence = False
                else:
                    print("WARNING: Entry {acc} has a malformed sequence".format(acc=accession))

            # Parse header information. Maybe we could extend this to regex?
            pre, accession, description = line[1:-1].split("|", 2)
            get_sequence = True

        else:
            # Simply append the sequences if we want to get it .
            if get_sequence:
                sequence += line[:-1]
    if sequence.isalpha() and sequence.isupper():
        yield sequence, pre, accession, description
    else:
        print("WARNING: Entry {acc} has a malformed sequence".format(acc=accession))



def _get_variant_features_string(substitutions: list, notes: list, evidences: list):
    """ Returns the FT Variant String of multiple variants"""
    final_str = "\n"
    for e in feature_list:
        final_str += "FT   VARIANT         " + e[0] + "\n"
        final_str += "FT                   /note=\"" + e[1] + "\"\n"
        final_str += "FT                   /evidence=\"" + e[2] + "\"\n" if e[2] else ""

    return final_str[:-1]


def _get_seq_string(sequence):
    """ Converts a string to SP-EMBL-txt """
    final_str = ""
    for seq in [sequence[i:i+60] for i in range(0, len(sequence), 60)]:
        final_str += "     "  + " ".join(seq[i:i+10] for i in range(0, len(seq), 10)) + "\n"

    return final_str


def _get_seq_header_string(sequence_len: int):
    """ Generates the sequence header for the sequence """
    return "SQ   SEQUENCE   {} AA;  {} MW;  {} CRC64;".format(
        sequence_len, 
        12345,  # Does not need to be set for ProtGraph
        "45D66B0D27B69FCD"  # Does not need to be set for ProtGraph
    )


def _get_id_ac_string(accession: str, gene: str, sequence_len: int):
    """ Generates the ID and AC line for SP-EMBL """
    id_str = "ID   {GENE:<24}{REVIEW:<18}{AA_COUNT} AA.\n".format(
        GENE=gene,
        REVIEW="Unreviewed;",
        AA_COUNT=sequence_len
    )
    acc_str = "AC   {};".format(accession)
    return id_str + acc_str


def _get_month(num):
    """ Get the 3 letter code of the month """
    return dict(
        [ (1, "JAN"), (2, "FEB"), (3, "MAR"), (4, "APR"), (5, "MAY"), (6, "JUN"),
        (7, "JUL"), (8, "AUG"), (9, "SEP"), (10, "OCT"), (11, "NOV"), (12, "DEC")]
    )[num]


def generate_sp_embl_enty( sequence, accession, opt_feature):
    """ Generates a valid SP-EMBL using sequence, accession and optional features. """
    
    # TODO DL add optional Features for FT
    return SWISS_EMBL_SKELETON.format(
        ID_AC=_get_id_ac_string(accession, accession, len(sequence)),
        DAY=date.today().day,
        MONTH=_get_month(date.today().month),
        YEAR=date.today().year,
        PROTEIN_DESC="Generated_by_ProtGraph",
        GENE=accession,
        ENSP=accession,
        FT="",
        SQ=_get_seq_header_string(len(sequence)),
        SEQ_BODY=_get_seq_string(sequence)
    )


def main():
    # Parse args
    args = parse_args()

    # Set in and output
    in_fasta = os.path.abspath(args.fasta_file[0])
    out_txt = os.path.abspath(args.output)
    # feature_mapping = os.path.abspath(args.feature_tables)  # TODO DL

    with open(in_fasta, "r") as in_file, open(out_txt, "w") as out_file:
        for sequence, pre, accession, description in tqdm.tqdm(get_next_fasta_entry(in_file), total=args.num_entries, unit="entries"):
            out_file.write(generate_sp_embl_enty(sequence, accession, None))
