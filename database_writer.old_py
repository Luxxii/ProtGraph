import igraph
import sqlalchemy
import json

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

from sqlalchemy import Column, BigInteger, String, JSON
from sqlalchemy.ext.declarative import declarative_base
Base = declarative_base()


import pyorient 


# todo check if graph is dag and only has one starting and end pooint (via degree)

# class Node(Base):
#     __tablename__ = "nodes"
#     id = Column(BigInteger, primary_key=True)
#     accession = Column(String)
#     aminoacid = Column(String)
#     attributes = Column(JSON)

#     def __repr__(self):
#        return "<Node(accession='{}', aminoacid='{}', attributes='{}')>".format(self.accession, self.aminoacid, self.attributes)

# class Edge(Base):
#     __tablename__ = "edges"
#     id = Column(BigInteger, primary_key=True)
#     accession = Column(String)
#     aminoacid = Column(String)
#     attributes = Column(JSON)

#     def __repr__(self):
#        return "<Node(accession='{}', aminoacid='{}', attributes='{}')>".format(self.accession, self.aminoacid, self.attributes)




def _get_qualifiers(list_of_qs):
    if list_of_qs is None:
        return None
    elif len(list_of_qs) == 0:
        return None
    else:
        l = []
        for k in list_of_qs:
            d = k.qualifiers
            d["type"] = k.type
            d["id"] = k.id
            l.append(d)
        return l


def insert_to_database(digested_graphs_queue, output_query):


    ### BATCH VERSION OF  Orient DB
    # while True:
    #     try: 
    #         graph_entry = digested_graphs_queue.get(timeout=180)
    #     except Exception:
    #         continue


    #     # Batch Version
    #     client = pyorient.OrientDB("localhost", 2424)
    #     client.set_session_token(True)
    #     session_id = client.connect("root", "root")
    #     client.db_open("graph", "root", "root")

        
    #     batch_cmd = ["begin;\n"]
    #     batch_main_nodes = ["let e{} = create vertex V content {};\n".format(x, json.dumps(y.attributes())) for x, y in enumerate(graph_entry.vs[:])]
        

    #     nodes_ids = ["$e" + str(x) for x in range(graph_entry.vcount())]
    #     sources_nodes = [nodes_ids[x.source] for x in graph_entry.es[:]]
    #     target_nodes  = [nodes_ids[x.target] for x in graph_entry.es[:]]
    #     content = [x.attributes() for x in graph_entry.es[:]]
    #     content_updated_qualifiers = [_get_qualifiers(c["qualifiers"]) for c in content]
    #     for x, y in zip(content, content_updated_qualifiers):
    #         x["qualifiers"] = y
        
    #     batch_main_edges = ["create edge E from {} to {} content {};".format(x, y, json.dumps(z)) for x, y, z in zip(sources_nodes, target_nodes, content)]
    #     batch_end = ["commit retry 100;\n"]

    #     results = client.batch( "".join(batch_cmd + batch_main_nodes + batch_main_edges + batch_end ))


    #     output_query.put(1)
        # To get Information of how many edges and Nodes are in the database
        #
        # Select ( SELECT COUNT(*) FROM V ) AS count1, ( SELECT COUNT(*) FROM E ) AS count2




        ## Non Batch Version
        # client = pyorient.OrientDB("localhost", 2424)
        # client.set_session_token(True)
        # session_id = client.connect("root", "root")
        # client.db_open("graph", "root", "root")

        
        # node_objects = [client.command("insert into V content " +  json.dumps(x.attributes())) for x in graph_entry.vs[:]]



        # sources_nodes = [node_objects[x.source][0]._rid for x in graph_entry.es[:]]
        # target_nodes  = [node_objects[x.target][0]._rid for x in graph_entry.es[:]]
        # content = [x.attributes() for x in graph_entry.es[:]]
        # content_updated_qualifiers = [_get_qualifiers(c["qualifiers"]) for c in content]
        # for x, y in zip(content, content_updated_qualifiers):
        #     x["qualifiers"] = y

        # edge_objects = [client.command("create edge E from {} to {} content {}".format(x, y, json.dumps(z))) for x, y, z in zip(sources_nodes, target_nodes, content)]


    ### SQL ALchemy
    # engine = create_engine('postgresql://postgres:developer@127.0.0.1:5433/node_edges', echo=False)
    # Session = sessionmaker(bind=engine)
    # session = Session()



    # while True:
    #     try: 
    #         graph_entry = digested_graphs_queue.get(timeout=180)
    #     except Exception:
    #         continue

    #     # If table is not existing!
    #     if not engine.dialect.has_table(engine, "nodes"):
    #         Node.__table__.create(bind=engine)
    #     if not engine.dialect.has_table(engine, "edges"):
    #         # Node.__table__.create(bind=engine)
    #         # TODO
    #         pass

    #     # Generate Key list for json
    #     json_keys = [x for x in graph_entry.vs[0].attribute_names() if not( x == "accession" or x == "aminoacid" )]

    #     # Generate Node Object
    #     db_nodes = [Node(accession=x["accession"], aminoacid=x["aminoacid"], attributes=json.dumps({y: x[y] for y in json_keys})) for x in graph_entry.vs[:]]

    #     # Add to session and commit
    #     session.add_all(db_nodes)
    #     session.commit()


        # our_user = session.query(Node).filter_by(aminoacid='M').first() 
